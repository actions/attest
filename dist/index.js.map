{"version":3,"file":"index.js","names":["attest_1","__webpack_require__","oci_1","subject_1","OCI_TIMEOUT","OCI_RETRY","createAttestation","async","subjects","predicate","opts","attestation","attest","predicateType","type","params","sigstore","sigstoreInstance","token","githubToken","result","length","pushToRegistry","subject","credentials","getRegistryCredentials","name","artifact","attachArtifactToImage","imageName","imageDigest","formatSubjectDigest","Buffer","from","JSON","stringify","bundle","mediaType","annotations","fetchOpts","timeout","retry","attestationDigest","digest","exports","SEARCH_PUBLIC_GOOD_URL","core","__importStar","main_1","inputs","subjectPath","getInput","subjectName","subjectDigest","subjectChecksums","predicatePath","getBooleanInput","showSummary","privateSigning","includes","run","github","fs_1","__importDefault","os_1","path_1","endpoints_1","predicate_1","style","ATTESTATION_FILE_NAME","ATTESTATION_PATHS_FILE_NAME","logHandler","level","args","debug","join","process","on","context","payload","repository","visibility","env","ACTIONS_ID_TOKEN_REQUEST_URL","Error","subjectFromInputs","downcaseName","predicateFromInputs","outputPath","default","tempDir","setOutput","att","logAttestation","writeFileSync","EOL","encoding","flag","baseDir","RUNNER_TEMP","outputSummaryPath","appendFileSync","warning","attestationID","attestationURL","logSummary","err","setFailed","innerErr","cause","info","mute","toString","removeListener","instanceName","startGroup","highlight","certificate","endGroup","tlogID","url","summary","addHeading","addList","write","basePath","mkdtempSync","sep","id","serverUrl","repo","owner","MAX_PREDICATE_SIZE_BYTES","existsSync","statSync","size","readFileSync","parse","COLOR_CYAN","COLOR_GRAY","COLOR_DEFAULT","str","glob","assert_1","crypto_1","sync_1","MAX_SUBJECT_COUNT","MAX_SUBJECT_CHECKSUM_SIZE_BYTES","DIGEST_ALGORITHM","HEX_STRING_RE","enabledInputs","filter","Boolean","toLowerCase","getSubjectFromPath","getSubjectFromDigest","getSubjectFromChecksums","fail","alg","Object","keys","sort","digestedSubjects","subjectPaths","parseSubjectPathList","paths","create","then","g","files","p","isFile","file","base","digestFile","some","s","push","match","split","getSubjectFromChecksumsFile","getSubjectFromChecksumsString","checksumsPath","stats","checksums","records","record","delimIndex","indexOf","flag_and_name","slice","startsWith","test","digestAlgorithm","algorithm","filePath","Promise","resolve","reject","hash","createHash","setEncoding","createReadStream","once","pipe","read","input","res","columns","relaxQuotes","relaxColumnCount","skipEmptyLines","item","map","pat","trim","__webpack_module_cache__","moduleId","cachedModule","undefined","module","threw","__webpack_modules__","call","m","__webpack_exports__"],"sources":["../src/attest.ts","../src/endpoints.ts","../src/index.ts","../src/main.ts","../src/predicate.ts","../src/style.ts","../src/subject.ts","../webpack/bootstrap","../webpack/startup"],"sourcesContent":["import { Attestation, Predicate, Subject, attest } from '@actions/attest'\nimport { attachArtifactToImage, getRegistryCredentials } from '@sigstore/oci'\nimport { formatSubjectDigest } from './subject'\n\nconst OCI_TIMEOUT = 30000\nconst OCI_RETRY = 3\n\nexport type SigstoreInstance = 'public-good' | 'github'\nexport type AttestResult = Attestation & {\n  attestationDigest?: string\n}\n\nexport const createAttestation = async (\n  subjects: Subject[],\n  predicate: Predicate,\n  opts: {\n    sigstoreInstance: SigstoreInstance\n    pushToRegistry: boolean\n    githubToken: string\n  }\n): Promise<AttestResult> => {\n  // Sign provenance w/ Sigstore\n  const attestation = await attest({\n    subjects,\n    predicateType: predicate.type,\n    predicate: predicate.params,\n    sigstore: opts.sigstoreInstance,\n    token: opts.githubToken\n  })\n\n  const result: AttestResult = attestation\n\n  if (subjects.length === 1 && opts.pushToRegistry) {\n    const subject = subjects[0]\n    const credentials = getRegistryCredentials(subject.name)\n    const artifact = await attachArtifactToImage({\n      credentials,\n      imageName: subject.name,\n      imageDigest: formatSubjectDigest(subject),\n      artifact: Buffer.from(JSON.stringify(attestation.bundle)),\n      mediaType: attestation.bundle.mediaType,\n      annotations: {\n        'dev.sigstore.bundle.content': 'dsse-envelope',\n        'dev.sigstore.bundle.predicateType': predicate.type\n      },\n      fetchOpts: { timeout: OCI_TIMEOUT, retry: OCI_RETRY }\n    })\n\n    // Add the attestation's digest to the result\n    result.attestationDigest = artifact.digest\n  }\n\n  return result\n}\n","export const SEARCH_PUBLIC_GOOD_URL = 'https://search.sigstore.dev'\n","/**\n * The entrypoint for the action.\n */\nimport * as core from '@actions/core'\nimport { run, RunInputs } from './main'\n\nconst inputs: RunInputs = {\n  subjectPath: core.getInput('subject-path'),\n  subjectName: core.getInput('subject-name'),\n  subjectDigest: core.getInput('subject-digest'),\n  subjectChecksums: core.getInput('subject-checksums'),\n  predicateType: core.getInput('predicate-type'),\n  predicate: core.getInput('predicate'),\n  predicatePath: core.getInput('predicate-path'),\n  pushToRegistry: core.getBooleanInput('push-to-registry'),\n  showSummary: core.getBooleanInput('show-summary'),\n  githubToken: core.getInput('github-token'),\n  // undocumented -- not part of public interface\n  privateSigning: ['true', 'True', 'TRUE', '1'].includes(\n    core.getInput('private-signing')\n  )\n}\n\n/* eslint-disable-next-line @typescript-eslint/no-floating-promises */\nrun(inputs)\n","import * as core from '@actions/core'\nimport * as github from '@actions/github'\nimport fs from 'fs'\nimport os from 'os'\nimport path from 'path'\nimport { AttestResult, SigstoreInstance, createAttestation } from './attest'\nimport { SEARCH_PUBLIC_GOOD_URL } from './endpoints'\nimport { PredicateInputs, predicateFromInputs } from './predicate'\nimport * as style from './style'\nimport {\n  SubjectInputs,\n  formatSubjectDigest,\n  subjectFromInputs\n} from './subject'\n\nimport type { Subject } from '@actions/attest'\n\nconst ATTESTATION_FILE_NAME = 'attestation.json'\nconst ATTESTATION_PATHS_FILE_NAME = 'created_attestation_paths.txt'\n\nexport type RunInputs = SubjectInputs &\n  PredicateInputs & {\n    pushToRegistry: boolean\n    githubToken: string\n    showSummary: boolean\n    privateSigning: boolean\n  }\n\n/* istanbul ignore next */\nconst logHandler = (level: string, ...args: unknown[]): void => {\n  // Send any HTTP-related log events to the GitHub Actions debug log\n  if (level === 'http') {\n    core.debug(args.join(' '))\n  }\n}\n\n/**\n * The main function for the action.\n * @returns {Promise<void>} Resolves when the action is complete.\n */\nexport async function run(inputs: RunInputs): Promise<void> {\n  process.on('log', logHandler)\n\n  // Provenance visibility will be public ONLY if we can confirm that the\n  // repository is public AND the undocumented \"private-signing\" arg is NOT set.\n  // Otherwise, it will be private.\n  const sigstoreInstance: SigstoreInstance =\n    github.context.payload.repository?.visibility === 'public' &&\n    !inputs.privateSigning\n      ? 'public-good'\n      : 'github'\n\n  try {\n    if (!process.env.ACTIONS_ID_TOKEN_REQUEST_URL) {\n      throw new Error(\n        'missing \"id-token\" permission. Please add \"permissions: id-token: write\" to your workflow.'\n      )\n    }\n\n    const subjects = await subjectFromInputs({\n      ...inputs,\n      downcaseName: inputs.pushToRegistry\n    })\n    const predicate = predicateFromInputs(inputs)\n\n    const outputPath = path.join(tempDir(), ATTESTATION_FILE_NAME)\n    core.setOutput('bundle-path', outputPath)\n\n    const att = await createAttestation(subjects, predicate, {\n      sigstoreInstance,\n      pushToRegistry: inputs.pushToRegistry,\n      githubToken: inputs.githubToken\n    })\n\n    logAttestation(subjects, att, sigstoreInstance)\n\n    // Write attestation bundle to output file\n    fs.writeFileSync(outputPath, JSON.stringify(att.bundle) + os.EOL, {\n      encoding: 'utf-8',\n      flag: 'a'\n    })\n\n    const baseDir = process.env.RUNNER_TEMP\n    /* istanbul ignore else */\n    if (baseDir) {\n      const outputSummaryPath = path.join(baseDir, ATTESTATION_PATHS_FILE_NAME)\n      // Append the output path to the attestations paths file\n      fs.appendFileSync(outputSummaryPath, outputPath + os.EOL, {\n        encoding: 'utf-8',\n        flag: 'a'\n      })\n    } else {\n      core.warning(\n        'RUNNER_TEMP environment variable is not set. Cannot write attestation paths file.'\n      )\n    }\n\n    /* istanbul ignore else */\n    if (att.attestationID) {\n      core.setOutput('attestation-id', att.attestationID)\n      core.setOutput('attestation-url', attestationURL(att.attestationID))\n    }\n\n    /* istanbul ignore else */\n    if (inputs.showSummary) {\n      await logSummary(att)\n    }\n  } catch (err) {\n    // Fail the workflow run if an error occurs\n    core.setFailed(\n      err instanceof Error ? err : /* istanbul ignore next */ `${err}`\n    )\n\n    // Log the cause of the error if one is available\n    /* istanbul ignore if */\n    if (err instanceof Error && 'cause' in err) {\n      const innerErr = err.cause\n      core.info(\n        style.mute(\n          innerErr instanceof Error ? innerErr.toString() : `${innerErr}`\n        )\n      )\n    }\n  } finally {\n    process.removeListener('log', logHandler)\n  }\n}\n\n// Log details about the attestation to the GitHub Actions run\nconst logAttestation = (\n  subjects: Subject[],\n  attestation: AttestResult,\n  sigstoreInstance: SigstoreInstance\n): void => {\n  if (subjects.length === 1) {\n    core.info(\n      `Attestation created for ${subjects[0].name}@${formatSubjectDigest(subjects[0])}`\n    )\n  } else {\n    core.info(`Attestation created for ${subjects.length} subjects`)\n  }\n\n  const instanceName =\n    sigstoreInstance === 'public-good' ? 'Public Good' : 'GitHub'\n  core.startGroup(\n    style.highlight(\n      `Attestation signed using certificate from ${instanceName} Sigstore instance`\n    )\n  )\n  core.info(attestation.certificate)\n  core.endGroup()\n\n  if (attestation.tlogID) {\n    core.info(\n      style.highlight(\n        'Attestation signature uploaded to Rekor transparency log'\n      )\n    )\n    core.info(`${SEARCH_PUBLIC_GOOD_URL}?logIndex=${attestation.tlogID}`)\n  }\n\n  /* istanbul ignore else */\n  if (attestation.attestationID) {\n    core.info(style.highlight('Attestation uploaded to repository'))\n    core.info(attestationURL(attestation.attestationID))\n  }\n\n  if (attestation.attestationDigest) {\n    core.info(style.highlight('Attestation uploaded to registry'))\n    core.info(`${subjects[0].name}@${attestation.attestationDigest}`)\n  }\n}\n\n// Attach summary information to the GitHub Actions run\nconst logSummary = async (attestation: AttestResult): Promise<void> => {\n  const { attestationID } = attestation\n\n  /* istanbul ignore else */\n  if (attestationID) {\n    const url = attestationURL(attestationID)\n    core.summary.addHeading('Attestation Created', 3)\n    core.summary.addList([`<a href=\"${url}\">${url}</a>`])\n    await core.summary.write()\n  }\n}\n\nconst tempDir = (): string => {\n  const basePath = process.env['RUNNER_TEMP']\n\n  /* istanbul ignore if */\n  if (!basePath) {\n    throw new Error('Missing RUNNER_TEMP environment variable')\n  }\n\n  return fs.mkdtempSync(path.join(basePath, path.sep))\n}\n\nconst attestationURL = (id: string): string =>\n  `${github.context.serverUrl}/${github.context.repo.owner}/${github.context.repo.repo}/attestations/${id}`\n","import fs from 'fs'\n\nimport type { Predicate } from '@actions/attest'\n\nexport type PredicateInputs = {\n  predicateType: string\n  predicate: string\n  predicatePath: string\n}\n\nconst MAX_PREDICATE_SIZE_BYTES = 16 * 1024 * 1024\n\n// Returns the predicate specified by the action's inputs. The predicate value\n// may be specified as a path to a file or as a string.\nexport const predicateFromInputs = (inputs: PredicateInputs): Predicate => {\n  const { predicateType, predicate, predicatePath } = inputs\n\n  if (!predicateType) {\n    throw new Error('predicate-type must be provided')\n  }\n\n  if (!predicatePath && !predicate) {\n    throw new Error('One of predicate-path or predicate must be provided')\n  }\n\n  if (predicatePath && predicate) {\n    throw new Error('Only one of predicate-path or predicate may be provided')\n  }\n\n  let params: string = predicate\n\n  if (predicatePath) {\n    if (!fs.existsSync(predicatePath)) {\n      throw new Error(`predicate file not found: ${predicatePath}`)\n    }\n\n    /* istanbul ignore next */\n    if (fs.statSync(predicatePath).size > MAX_PREDICATE_SIZE_BYTES) {\n      throw new Error(\n        `predicate file exceeds maximum allowed size: ${MAX_PREDICATE_SIZE_BYTES} bytes`\n      )\n    }\n\n    params = fs.readFileSync(predicatePath, 'utf-8')\n  } else {\n    if (predicate.length > MAX_PREDICATE_SIZE_BYTES) {\n      throw new Error(\n        `predicate string exceeds maximum allowed size: ${MAX_PREDICATE_SIZE_BYTES} bytes`\n      )\n    }\n\n    params = predicate\n  }\n\n  return { type: predicateType, params: JSON.parse(params) }\n}\n","const COLOR_CYAN = '\\x1B[36m'\nconst COLOR_GRAY = '\\x1B[38;5;244m'\nconst COLOR_DEFAULT = '\\x1B[39m'\n\n// Emphasis string using ANSI color codes\nexport const highlight = (str: string): string =>\n  `${COLOR_CYAN}${str}${COLOR_DEFAULT}`\n\n// De-emphasize string using ANSI color codes\nexport const mute = (str: string): string =>\n  `${COLOR_GRAY}${str}${COLOR_DEFAULT}`\n","import * as glob from '@actions/glob'\nimport assert from 'assert'\nimport crypto from 'crypto'\nimport { parse } from 'csv-parse/sync'\nimport fs from 'fs'\nimport os from 'os'\nimport path from 'path'\n\nimport type { Subject } from '@actions/attest'\n\nconst MAX_SUBJECT_COUNT = 1024\nconst MAX_SUBJECT_CHECKSUM_SIZE_BYTES = 512 * MAX_SUBJECT_COUNT\nconst DIGEST_ALGORITHM = 'sha256'\nconst HEX_STRING_RE = /^[0-9a-fA-F]+$/\n\nexport type SubjectInputs = {\n  subjectPath: string\n  subjectName: string\n  subjectDigest: string\n  subjectChecksums: string\n  downcaseName?: boolean\n}\n// Returns the subject specified by the action's inputs. The subject may be\n// specified as a path to a file or as a digest. If a path is provided, the\n// file's digest is calculated and returned along with the subject's name. If a\n// digest is provided, the name must also be provided.\nexport const subjectFromInputs = async (\n  inputs: SubjectInputs\n): Promise<Subject[]> => {\n  const {\n    subjectPath,\n    subjectDigest,\n    subjectName,\n    subjectChecksums,\n    downcaseName\n  } = inputs\n\n  const enabledInputs = [subjectPath, subjectDigest, subjectChecksums].filter(\n    Boolean\n  )\n  if (enabledInputs.length === 0) {\n    throw new Error(\n      'One of subject-path, subject-digest, or subject-checksums must be provided'\n    )\n  }\n\n  if (enabledInputs.length > 1) {\n    throw new Error(\n      'Only one of subject-path, subject-digest, or subject-checksums may be provided'\n    )\n  }\n\n  if (subjectDigest && !subjectName) {\n    throw new Error('subject-name must be provided when using subject-digest')\n  }\n\n  // If push-to-registry is enabled, ensure the subject name is lowercase\n  // to conform to OCI image naming conventions\n  const name = downcaseName ? subjectName.toLowerCase() : subjectName\n\n  switch (true) {\n    case !!subjectPath:\n      return getSubjectFromPath(subjectPath, name)\n    case !!subjectDigest:\n      return [getSubjectFromDigest(subjectDigest, name)]\n    case !!subjectChecksums:\n      return getSubjectFromChecksums(subjectChecksums)\n    /* istanbul ignore next */\n    default:\n      // This should be unreachable, but TS requires a default case\n      assert.fail('unreachable')\n  }\n}\n\n// Returns the subject's digest as a formatted string of the form\n// \"<algorithm>:<digest>\".\nexport const formatSubjectDigest = (subject: Subject): string => {\n  const alg = Object.keys(subject.digest).sort()[0]\n  return `${alg}:${subject.digest[alg]}`\n}\n\n// Returns the subject specified by the path to a file. The file's digest is\n// calculated and returned along with the subject's name.\nconst getSubjectFromPath = async (\n  subjectPath: string,\n  subjectName?: string\n): Promise<Subject[]> => {\n  const digestedSubjects: Subject[] = []\n\n  // Parse the list of subject paths\n  const subjectPaths = parseSubjectPathList(subjectPath).join('\\n')\n\n  // Expand the globbed paths to a list of actual paths\n  const paths = await glob.create(subjectPaths).then(async g => g.glob())\n\n  // Filter path list to just the files (not directories)\n  const files = paths.filter(p => fs.statSync(p).isFile())\n\n  if (files.length > MAX_SUBJECT_COUNT) {\n    throw new Error(\n      `Too many subjects specified. The maximum number of subjects is ${MAX_SUBJECT_COUNT}.`\n    )\n  }\n\n  for (const file of files) {\n    const name = subjectName || path.parse(file).base\n    const digest = await digestFile(DIGEST_ALGORITHM, file)\n\n    // Only add the subject if it is not already in the list\n    if (\n      !digestedSubjects.some(\n        s => s.name === name && s.digest[DIGEST_ALGORITHM] === digest\n      )\n    ) {\n      digestedSubjects.push({ name, digest: { [DIGEST_ALGORITHM]: digest } })\n    }\n  }\n\n  if (digestedSubjects.length === 0) {\n    throw new Error(`Could not find subject at path ${subjectPath}`)\n  }\n\n  return digestedSubjects\n}\n\n// Returns the subject specified by the digest of a file. The digest is returned\n// along with the subject's name.\nconst getSubjectFromDigest = (\n  subjectDigest: string,\n  subjectName: string\n): Subject => {\n  if (!subjectDigest.match(/^sha256:[A-Za-z0-9]{64}$/)) {\n    throw new Error(\n      'subject-digest must be in the format \"sha256:<hex-digest>\"'\n    )\n  }\n  const [alg, digest] = subjectDigest.split(':')\n\n  return {\n    name: subjectName,\n    digest: { [alg]: digest }\n  }\n}\n\nconst getSubjectFromChecksums = (subjectChecksums: string): Subject[] => {\n  if (fs.existsSync(subjectChecksums)) {\n    return getSubjectFromChecksumsFile(subjectChecksums)\n  } else {\n    return getSubjectFromChecksumsString(subjectChecksums)\n  }\n}\n\nconst getSubjectFromChecksumsFile = (checksumsPath: string): Subject[] => {\n  const stats = fs.statSync(checksumsPath)\n  if (!stats.isFile()) {\n    throw new Error(`subject checksums file not found: ${checksumsPath}`)\n  }\n\n  /* istanbul ignore next */\n  if (stats.size > MAX_SUBJECT_CHECKSUM_SIZE_BYTES) {\n    throw new Error(\n      `subject checksums file exceeds maximum allowed size: ${MAX_SUBJECT_CHECKSUM_SIZE_BYTES} bytes`\n    )\n  }\n\n  const checksums = fs.readFileSync(checksumsPath, 'utf-8')\n  return getSubjectFromChecksumsString(checksums)\n}\n\nconst getSubjectFromChecksumsString = (checksums: string): Subject[] => {\n  const subjects: Subject[] = []\n\n  const records: string[] = checksums.split(os.EOL).filter(Boolean)\n\n  for (const record of records) {\n    // Find the space delimiter following the digest\n    const delimIndex = record.indexOf(' ')\n\n    // Skip any line that doesn't have a delimiter\n    if (delimIndex === -1) {\n      continue\n    }\n\n    // It's common for checksum records to have a leading flag character before\n    // the artifact name. It will be either a '*' or a space.\n    const flag_and_name = record.slice(delimIndex + 1)\n    const name =\n      flag_and_name.startsWith('*') || flag_and_name.startsWith(' ')\n        ? flag_and_name.slice(1)\n        : flag_and_name\n\n    const digest = record.slice(0, delimIndex)\n\n    if (!HEX_STRING_RE.test(digest)) {\n      throw new Error(`Invalid digest: ${digest}`)\n    }\n\n    subjects.push({\n      name,\n      digest: { [digestAlgorithm(digest)]: digest }\n    })\n  }\n\n  return subjects\n}\n\n// Calculates the digest of a file using the specified algorithm. The file is\n// streamed into the digest function to avoid loading the entire file into\n// memory. The returned digest is a hex string.\nconst digestFile = async (\n  algorithm: string,\n  filePath: string\n): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const hash = crypto.createHash(algorithm).setEncoding('hex')\n    fs.createReadStream(filePath)\n      .once('error', reject)\n      .pipe(hash)\n      .once('finish', () => resolve(hash.read()))\n  })\n}\n\nconst parseSubjectPathList = (input: string): string[] => {\n  const res: string[] = []\n\n  const records: string[][] = parse(input, {\n    columns: false,\n    relaxQuotes: true,\n    relaxColumnCount: true,\n    skipEmptyLines: true\n  })\n\n  for (const record of records) {\n    res.push(...record)\n  }\n\n  return res.filter(item => item).map(pat => pat.trim())\n}\n\nconst digestAlgorithm = (digest: string): string => {\n  switch (digest.length) {\n    case 64:\n      return 'sha256'\n    case 128:\n      return 'sha512'\n    default:\n      throw new Error(`Unknown digest algorithm: ${digest}`)\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(79407);\n"],"mappings":"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","ignoreList":[]}