# attest

GitHub Action to sign and upload [in-toto Attestation Predicates][0] for
artifacts as part of a workflow.

## Usage

Within the GitHub Actions workflow which builds some artifact you would like to
attest,

1. Ensure that the following permissions are set:

   ```yaml
   permissions:
     id-token: write
     contents: write
   ```

   The `id-token` permission gives the action the ability to mint the OIDC token
   necessary to request a Sigstore signing certificate. The `contents`
   permission is necessary to persist the attestation.

   > **NOTE**: The set of required permissions will be refined in a future
   > release.

1. After your artifact build step, add the following:

   ```yaml
   - uses: actions/attest@main
     with:
       predicate-path: './predicate.json'
       predicate-type: 'https://in-toto.io/attestation/release/v0.1'
       subject-path: '${{ github.workspace }}/PATH_TO_FILE'
   ```

   The `subject-path` parameter should identity the artifact for which you want
   to generate an attestation.

### What is being attested?

The generated attestation is based on the inputs of `predicate-path` and `predicate-type`

```json
{
  "_type": "https://in-toto.io/Statement/v1",
  "subject": [
    {
      "name": "subject",
      "digest": {
        "sha256": "7d070f6b64d9bcc530fe99cc21eaaa4b3c364e0b2d367d7735671fa202a03b32"
      }
    }
  ],
  "predicateType": $predicateType,
  "predicate": {
    ...
  }
}
```

The predicate statement is signed with a short-lived, [Sigstore][1]-issued
certificate.

If the repository initiating the GitHub Actions workflow is public, the public
instance of Sigstore will be used to generate the attestation signature. If the
repository is private, it will use the GitHub private Sigstore instance.

### Where does the attestation go?

On the actions summary page for a repository you'll see an "Attestations" link
which will take you to a list of all the attestations generated by workflows in
that repository.

![Actions summary view](./.github/attestations.png)

### How are attestations verified?

Attestations can be verified using the [gh-attestation][2] extension for the
[GitHub CLI][3].

## Customization

See [action.yml](action.yml)

### Inputs

- `predicate` - String containing the value for the attestation predicate.

  Must supply exactly one of "predicate-path" or "predicate".

- `predicate-path` - Path to the file which contains the content for the
  attestation predicate.
  
  Must supply exactly one of "predicate-path" or "predicate".

- `predicate-type` - URI identifying the type of the predicate.

- `subject-path` - Path to the artifact for which the predicate statement will be
  generated.

  Must specify exactly one of `subject-path` or `subject-digest`. Wildcards can
  be used to identify more than one artifact.

- `subject-digest` - Digest of the subject for which the predicate statement
  will be generated.

  Only SHA-256 digests are accepted and the supplied value must be in the form
  "sha256:\<hex-encoded-digest\>". Must specify exactly one of `subject-path` or
  `subject-digest`.

- `subject-name` - Subject name as it should appear in the predicate statement.

  Required when the subject is identified by the `subject-digest` parameter.
  When attesting container images, the name should be the fully qualified image
  name.

- `push-to-registry` - If true, the signed attestation is pushed to the
  container registry identified by the `subject-name`. Default: `false`.

- `github-token` - Token used to make authenticated requests to the GitHub API.
  Default: `${{ github.token }}`.

  The supplied token must have the permissions necessary to write attestations
  to the repository.

### Outputs

- `bundle-path` - The file path of JSON-serialized [Sigstore bundle][4]
  containing the attestation and related verification material.

## Sample Workflows

### Identify Artifact by Path

For the basic use case, simply add the `attest` action to
your workflow and supply the path to the artifact for which you want to generate
attestation.

```yaml
name: attest

on:
  workflow_dispatch:

jobs:
  build:
    permissions:
      id-token: write
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Build artifact
        run: make some-app
      - name: Attest
        uses: actions/attest@main
        with:
          predicate: |
            '{ "purl": $YOUR_PURL, "releaseId": $YOUR_RELEASE_ID }'
          predicate-type: 'https://in-toto.io/attestation/release/v0.1'
          subject-path: '${{ github.workspace }}/some-app'
```

### Identify Artifacts by Wildcard

If you are generating multiple artifacts, you can generate attest for
each artifact by using a wildcard in the `subject-path` input.

```yaml
name: build-wildcard-with-attest

on:
  workflow_dispatch:

jobs:
  build:
    permissions:
      id-token: write
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v4
      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v5
        with:
          distribution: goreleaser
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Attest artifact
        uses: actions/attest@main
        with:
          predicate: |
            '{ "purl": $YOUR_PURL, "releaseId": $YOUR_RELEASE_ID }'
          predicate-type: 'https://in-toto.io/attestation/release/v0.1'
          subject-path: 'dist/**/my-bin-*'
```

For supported wildcards along with behavior and documentation, see
[@actions/glob][5] which is used internally to search for files.

### Container Image

When working with container images you may not have a `subject-path` value you
can supply. In this case you can invoke the action with the `subject-name` and
`subject-digest` inputs.

If you want to publish the attestation to the container registry with the
`push-to-registry` option, it is important that the `subject-name` specify the
fully-qualified image name (e.g. "ghcr.io/user/app" or
"acme.azurecr.io/user/app"). Do NOT include a tag as part of the image name --
the specific image being attested is identified by the supplied digest.

> **NOTE**: When pushing to Docker Hub, please use "index.docker.io" as the
> registry portion of the image name.

```yaml
name: build-image-with-attest

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      packages: write
      contents: write
    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: ${{ github.repository }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push image
        id: push
        uses: docker/build-push-action@v5.0.0
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
      - name: Attest
        uses: actions/attest@main
        id: attest
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          predicate: |
            '{ "purl": $YOUR_PURL, "releaseId": $YOUR_RELEASE_ID }'
          predicate-type: 'https://in-toto.io/attestation/release/v0.1'
```

[0]: https://github.com/in-toto/attestation/blob/main/spec/predicates/README.md
[1]: https://www.sigstore.dev/
[2]: https://github.com/github-early-access/gh-attestation
[3]: https://cli.github.com/
[4]: https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto
[5]: https://github.com/actions/toolkit/tree/main/packages/glob#patterns
